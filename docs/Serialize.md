## 序列化相关

### 1. Java 中，Serializable 与 Externalizable 的区别？

Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。 



### 2. java序列化的方式？

实现Serializable接口、实现Externalizable接口（一般只希望序列化一部分数据，其他数据都使用transient修饰的话有点麻烦，这时候可以使用externalizable接口，指定序列化的属性）。



1、如果子类实现Serializable接口而父类未实现时，父类不会被序列化，但此时父类必须有个无参构造方法，否则会抛InvalidClassException异常。

2、静态变量不会被序列化，那是类的“菜”，不是对象的。

3、transient关键字修饰变量可以限制序列化。

4、虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致，就是 private static final long serialVersionUID = 1L。

5、[Java](http://lib.csdn.net/base/javase) 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。反序列化时，恢复引用关系。

6、序列化到同一个文件时，如第二次修改了相同对象属性值再次保存时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次 writeObject 需要特别注意这个问题(基于第5点)。



- 当父类实现了Serializable接口的时候，所有的子类都能序列化
- 子类实现了Serializable接口，父类没有，父类中的属性不能被序列化(不报错，但是数据会丢失)
- 如果序列化的属性是对象，对象必须也能序列化，否则会报错
- 反序列化的时候，如果对象的属性有修改或则删减，修改的部分属性会丢失，但是不会报错
- 在反序列化的时候serialVersionUID被修改的话，会反序列化失败