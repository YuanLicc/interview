# 基础概念

## 1. 面向对象

### 1.1 概念



### 1.2 问题

#### 1.2.1 面向对象软件开发优点 ？

回答1：

- 代码开发模块化，更易维护和修改。
- 代码复用。
- 增强代码的可靠性和灵活性。
- 增加代码的可理解性。



#### 1.2.2 抽象类和接口的区别，类可以继承多个类吗？接口可以继承多个接口吗？类可以实现多个接口吗？

- 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 
- 抽象类要被子类继承，接口要被类实现。　　
- 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 
- 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 
- 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该        类也只能为抽象类。 
- 抽象方法只能申明，不能实现。 
- 抽象类里可以没有抽象方法 。
- 如果一个类里有抽象方法，那么这个类只能是抽象类 。
- 抽象方法要被实现，所以不能是静态的，也不能是私有的。 
- 接口可继承接口，并可多继承接口，但类只能单根继承。



#### 1.2.3 继承和聚合的区别在哪？

继承指的是一个类（称为子类、子类接口）继承另外一个类（称为父类、父接口）的功能，并可以增加它自己的新功能，继承是类与类或者接口之间最常见的关系。在 `Java` 中此类关系通过关键字 `extends` 明确标识。 



#### 1.2.4 什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？  

不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。 



#### 1.2.5 我们能创建一个包含可变对象的不可变对象吗？ 

是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。



#### 1.2.6 Java 中应该使用什么数据类型来代表价格？ 

如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。 



#### 1.2.7 存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B？

 可以，向下转型。但是不建议使用，容易出现类型转型异常. 



#### 1.2.8 JRE、JDK、JVM 及 JIT 之间有什么不同？

JRE 代表 Java 运行时（Java run-time），是运行 Java 应用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。 

附（关系图）：

![JDKãJREãJVMä¸èçåºå«ä¸èç³» - ä»¥å¾·ç³äºº - ââæ¨è¸¢æ°å·¥ Playkidââ](http://img1.ph.126.net/A2iWlmXbFe6tSz2rRGkz-A==/727331339920439686.jpg)  

#### 1.2.9 final、finalize 和 finally 的不同之处？

final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。 



#### 1.2.10 Java 中的编译期常量是什么？使用它又什么风险？

公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。 



#### 1.2.11 说出几条 Java 中方法重载的最佳实践？

a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。  

b）如果重载的方法参数个数多于 5 个，采用可变参数。 



#### 1.2.12 接口是什么？为什么要使用接口而不是直接使用具体类？

接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。



#### 1.2.13 Java 中，抽象类与接口之间有什么不同？

Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。关于这个问题的讨论请查看答案。 



#### 1.2.14 抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？

一个类可以实现多个接口，但只能继承一个抽象类；抽象类可以包含具体的方法，接口所有的方法都是抽象的（JDK8开始新增功能接口中有default方法）；抽象类可以声明和使用字段，接口则不能，但可以创建静态的final常量；抽象类的方法可以是protected、public、private或者默认的package，接口的方法都是public；抽象类可以定义构造函数，接口不能；接口被声明为public，省略后，包外的类不能访问接口。



#### 1.2.15 继承和组合之间有什么不同？

虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。



#### 1.2.16 描述 Java 中的重载和重写？

重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。  



#### 1.2.17 Java 中，嵌套公共静态类与顶级类有什么不同？

类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。



#### 1.2.18 OOP 中的 组合、聚合和关联有什么区别？

如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。 



#### 1.2.19 嵌套静态类与顶级类有什么区别？

一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。 



#### 1.2.20 Java 中，受检查异常 和 不受检查异常的区别？

受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过 throws 子句声明。其中一种情况是 Exception 的子类但不是 RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶段不受编译器的检查。 



#### 1.2.21 Java 中，throw 和 throws 有什么区别？

throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如： throw new IllegalArgumentException(“size must be multiple of 2″) 而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。



#### 1.2.22 Object中的方法

- hashCode()：用户获取对象的hash值，用于检索。

- queals()：用于确认两个对象是否相等；补充，哈希值相同的对象不一定equals()，但equals()的两个对象，hash值一定相等。

- toString()：返回一个String对象，用来标识自己。

- getClass()：返回一个class对象，打印的格式一般为  class package.name.xxx，经常用于java的反射机制。

- clone()：用来另存一个当前存在的对象。

- finalize()：垃圾回收的时候回用到，匿名对象回收之前会调用到。

- wait()：用于让当前线程失去操作权限，当前线程进入等待序列。

- wait(long)、wait(long,int)：用户设定下一次获取锁的距离当前释放锁的间隔时间。

- notify()：用于随机通知一个持有对象锁的线程获取操作的权限。

- notifyAll()：用于通知所有持有对象锁的线程获取操作权限。



#### 1.2.23 传值和传引用的区别，java是怎么样的，有没有传值传引用？

首先，java中是没有指针的，只存在值传递；而我们经常看到对于对象的传递似乎有点像引用传递，可以改变对象中的某个属性的值，请不要被这个假象蒙蔽了双眼，实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以还是按值传递。

传值调用时，改变的是形参的值，并没有改变实参的值，实参的值可以传递给形参，但是这个传递是单向的，形参不能传递会实参。

传引用调用时，如果参数是对象，无论是对象做了何种操作，都不会改变实参对象的引用，但是如果改变了对象的内容，就会改变实参对象的内容。



#### 1.2.24 什么是堆和栈，它们在哪儿？

​	栈是为执行线程留出的内存空间。当函数被调用的时候，栈顶为局部变量和一些 bookkeeping 数据预留块。当函数执行完毕，块就没有用了，可能在下次的函数调用的时候再被使用。栈通常用后进先出（LIFO）的方式预留空间；因此最近的保留块（reserved block）通常最先被释放。这么做可以使跟踪堆栈变的简单；从栈中释放块（free block）只不过是指针的偏移而已。

​	堆（heap）是为动态分配预留的内存空间。和栈不一样，从堆上分配和重新分配块没有固定模式；你可以在任何时候分配和释放它。这样使得跟踪哪部分堆已经被分配和被释放变的异常复杂；有许多定制的堆分配策略用来为不同的使用模式下调整堆的性能。

​	每一个线程都有一个栈，但是每一个应用程序通常都只有一个堆（尽管为不同类型分配内存使用多个堆的情况也是有的）。

1. 当线程创建的时候，操作系统（OS）为每一个系统级（system-level）的线程分配栈。通常情况下，操作系统通过调用语言的运行时（runtime）去为应用程序分配堆。
2. 栈附属于线程，因此当线程结束时栈被回收。堆通常通过运行时在应用程序启动时被分配，当应用程序（进程）退出时被回收。
3. 当线程被创建的时候，设置栈的大小。在应用程序启动的时候，设置堆的大小，但是可以在需要的时候扩展（分配器向操作系统申请更多的内存）。 
4. 栈比堆要快，因为它存取模式使它可以轻松的分配和重新分配内存（指针/整型只是进行简单的递增或者递减运算），然而堆在分配和释放的时候有更多的复杂的 bookkeeping 参与。另外，在栈上的每个字节频繁的被复用也就意味着它可能映射到处理器缓存中，所以很快（译者注：局部性原理）。

**Stack:**

1. 和堆一样存储在计算机 RAM 中。
2. 在栈上创建变量的时候会扩展，并且会自动回收。
3. 相比堆而言在栈上分配要快的多。
4. 用数据结构中的栈实现。
5. 存储局部数据，返回地址，用做参数传递。
6. 当用栈过多时可导致栈溢出（无穷次（大量的）的递归调用，或者大量的内存分配）。
7. 在栈上的数据可以直接访问（不是非要使用指针访问）。
8. 如果你在编译之前精确的知道你需要分配数据的大小并且不是太大的时候，可以使用栈。
9. 当你程序启动时决定栈的容量上限。

**Heap：**

1. 和栈一样存储在计算机RAM。
2. 在堆上的变量必须要手动释放，不存在作用域的问题。数据可用 delete, delete[] 或者 free 来释放。
3. 相比在栈上分配内存要慢。
4. 通过程序按需分配。
5. 堆是在任何内存中动态和随机分配的（内存的）统称；也就是无序的。内存通常由操作系统分配，通过应用程序调用 API 接口去实现分配。在管理动态分配内存上会有一些额外的开销，不过这由操作系统来处理。 
6. 大量的分配和释放可造成内存碎片。
7. 在 C++ 中，在堆上创建数的据使用指针访问，用 new 或者 malloc 分配内存。
8. 如果申请的缓冲区过大的话，可能申请失败。
9. 在运行期间你不知道会需要多大的数据或者你需要分配大量的内存的时候，建议你使用堆。
10. 可能造成内存泄露。