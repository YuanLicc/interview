## 并发

#### 1 线程基础

##### 1 线程状态

![线程状态](../images/thread-state.svg)

##### 2 线程关闭

可以调用 `stop()`、`destory()` 函数强制杀死线程，但是强制杀死线程可能导致线程使用的资源不能正常关闭，所以可以利用线程间的通信机制优雅的让线程正常关闭。

- 设置为守护线程

  当所有非守护线程执行完毕后，守护线程会随着关闭。

- 设置标志位

```java
public class ClosableThread extends Thread{
    private boolean isStop = false;
    public void run() {
        while (!isStop) {
            // 非阻塞代码，若此处代码块存在阻塞，调用 stopThread() 方法，
            // 线程不能及时响应，或者永远阻塞住，无法关闭
        }
    }
    public void stopThread() {
        isStop = true;
    }
}
```

- 中断

  `interrupt()` 函数可以使那些声明了会抛出 `InterruptedExcaption` 的函数抛出异常。对应线程状态为 `WAITING` 或者`TIMED_WAITING` 的阻塞都是可以被函数 `interrtpt()` 造成异常，而 `BLOKED` 状态则不会。所以可以认为 `synchronized` 获取锁的过程是不能被中断的。其实是否可以中断是由是否对中断标志 `isInterrupted()` 做出对应的抛出异常的动作决定的，查看 `AQS`中可被中断的获取锁的源码如下：

```java
public final void acquireInterruptibly(int arg) throws InterruptedException {
    // 首先判断是否已经被设置为中断状态，是则直接抛出异常
    if (Thread.interrupted())
        throw new InterruptedException();
    // 首先尝试获取锁（举个例子：尝试获取一次或者判断获取锁的是不是当前线程）
    if (!tryAcquire(arg))
        // 获取锁失败后采用可中断方式获取锁
        doAcquireInterruptibly(arg);
}

private void doAcquireInterruptibly(int arg) throws InterruptedException {
    // 既然是尝试获取失败才进入此方法，那就首先将线程放入等待队列（链表）
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        // 无限循环
        for (;;) {
            // 获取当前节点的前一个节点
            final Node p = node.predecessor();
            // 如果前一个节点等于头结点则尝试获取锁，若成功，则返回
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            // 判断是否在获取锁失败后是否需要让线程进入 waiting 状态；
            // park 线程，出现被唤醒的条件（其它线程释放锁唤醒或者中断信号唤醒）后返回线程的中断状态
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                // 若返回的中断状态为 true，则抛出异常
                throw new InterruptedException();
        }
    } finally {
        // 中断异常后退出获取锁，设置节点的状态等
        if (failed)
            cancelAcquire(node);
    }
}
```





